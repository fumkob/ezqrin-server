// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for CheckInMethod.
const (
	Manual CheckInMethod = "manual"
	Qrcode CheckInMethod = "qrcode"
)

// Defines values for EventStatus.
const (
	EventStatusCancelled EventStatus = "cancelled"
	EventStatusCompleted EventStatus = "completed"
	EventStatusDraft     EventStatus = "draft"
	EventStatusOngoing   EventStatus = "ongoing"
	EventStatusPublished EventStatus = "published"
)

// Defines values for ParticipantStatus.
const (
	ParticipantStatusCancelled ParticipantStatus = "cancelled"
	ParticipantStatusConfirmed ParticipantStatus = "confirmed"
	ParticipantStatusDeclined  ParticipantStatus = "declined"
	ParticipantStatusTentative ParticipantStatus = "tentative"
)

// Defines values for PaymentStatus.
const (
	Paid   PaymentStatus = "paid"
	Unpaid PaymentStatus = "unpaid"
)

// Defines values for UserRole.
const (
	Admin     UserRole = "admin"
	Organizer UserRole = "organizer"
	Staff     UserRole = "staff"
)

// Defines values for OrderParam.
const (
	OrderParamAsc  OrderParam = "asc"
	OrderParamDesc OrderParam = "desc"
)

// Defines values for GetEventsParamsOrder.
const (
	GetEventsParamsOrderAsc  GetEventsParamsOrder = "asc"
	GetEventsParamsOrderDesc GetEventsParamsOrder = "desc"
)

// Defines values for ListCheckInsParamsSort.
const (
	CheckedInAt     ListCheckInsParamsSort = "checked_in_at"
	ParticipantName ListCheckInsParamsSort = "participant_name"
)

// Defines values for ListCheckInsParamsOrder.
const (
	ListCheckInsParamsOrderAsc  ListCheckInsParamsOrder = "asc"
	ListCheckInsParamsOrderDesc ListCheckInsParamsOrder = "desc"
)

// Defines values for ListParticipantsParamsOrder.
const (
	ListParticipantsParamsOrderAsc  ListParticipantsParamsOrder = "asc"
	ListParticipantsParamsOrderDesc ListParticipantsParamsOrder = "desc"
)

// Defines values for DownloadParticipantQRCodeParamsFormat.
const (
	Png DownloadParticipantQRCodeParamsFormat = "png"
	Svg DownloadParticipantQRCodeParamsFormat = "svg"
)

// AuthResponse defines model for AuthResponse.
type AuthResponse struct {
	// AccessToken JWT access token for API authentication
	AccessToken string `json:"access_token"`

	// ExpiresIn Access token expiration time in seconds (900 = 15 minutes)
	ExpiresIn int `json:"expires_in"`

	// RefreshToken Refresh token for obtaining new access tokens
	RefreshToken string `json:"refresh_token"`

	// TokenType Token type (always "Bearer")
	TokenType string `json:"token_type"`
	User      User   `json:"user"`
}

// BulkCreateParticipantsRequest defines model for BulkCreateParticipantsRequest.
type BulkCreateParticipantsRequest struct {
	// Participants Array of participants to create (max 1000)
	Participants []CreateParticipantRequest `json:"participants"`
}

// BulkCreateParticipantsResponse defines model for BulkCreateParticipantsResponse.
type BulkCreateParticipantsResponse struct {
	// CreatedCount Number of participants successfully created
	CreatedCount int `json:"created_count"`

	// Errors List of errors for failed participants
	Errors *[]struct {
		// Email Email of the failed participant
		Email openapi_types.Email `json:"email"`

		// Error Error message
		Error string `json:"error"`

		// Index Index in the original request array
		Index int `json:"index"`
	} `json:"errors,omitempty"`

	// FailedCount Number of participants that failed to create
	FailedCount int `json:"failed_count"`

	// Participants List of successfully created participants
	Participants []Participant `json:"participants"`
}

// CheckIn defines model for CheckIn.
type CheckIn struct {
	// CheckedInAt Check-in timestamp (ISO 8601, default NOW())
	CheckedInAt *time.Time `json:"checked_in_at,omitempty"`

	// CheckedInBy User who performed check-in
	CheckedInBy *struct {
		Id   *openapi_types.UUID `json:"id,omitempty"`
		Name *string             `json:"name,omitempty"`
	} `json:"checked_in_by,omitempty"`

	// CheckinMethod Check-in method
	CheckinMethod CheckInMethod `json:"checkin_method"`

	// DeviceInfo Device metadata (max 5KB JSON)
	DeviceInfo *map[string]interface{} `json:"device_info,omitempty"`

	// EventId Associated event ID
	EventId *openapi_types.UUID `json:"event_id,omitempty"`

	// Id Check-in unique identifier
	Id *openapi_types.UUID `json:"id,omitempty"`

	// ParticipantId Checked-in participant ID
	ParticipantId *openapi_types.UUID `json:"participant_id,omitempty"`
}

// CheckInListResponse defines model for CheckInListResponse.
type CheckInListResponse struct {
	// Checkins List of check-ins with participant information
	Checkins []struct {
		// CheckedInAt Check-in timestamp (ISO 8601)
		CheckedInAt time.Time `json:"checked_in_at"`

		// CheckedInBy User who performed the check-in
		CheckedInBy struct {
			// Id User ID
			Id openapi_types.UUID `json:"id"`

			// Name User full name
			Name string `json:"name"`
		} `json:"checked_in_by"`

		// CheckinMethod Check-in method
		CheckinMethod CheckInMethod `json:"checkin_method"`

		// DeviceInfo Device metadata
		DeviceInfo *map[string]interface{} `json:"device_info,omitempty"`

		// EventId Associated event ID
		EventId openapi_types.UUID `json:"event_id"`

		// Id Check-in unique identifier
		Id openapi_types.UUID `json:"id"`

		// Participant Participant information
		Participant struct {
			// Email Participant email
			Email openapi_types.Email `json:"email"`

			// EmployeeId Employee ID
			EmployeeId *string `json:"employee_id"`

			// Name Participant full name
			Name string `json:"name"`
		} `json:"participant"`

		// ParticipantId Checked-in participant ID
		ParticipantId openapi_types.UUID `json:"participant_id"`
	} `json:"checkins"`
	Pagination PaginationMeta `json:"pagination"`
}

// CheckInMethod Check-in method
type CheckInMethod string

// CheckInRequest defines model for CheckInRequest.
type CheckInRequest struct {
	// DeviceInfo Device metadata for check-in tracking (max 5KB JSON, optional)
	DeviceInfo *map[string]interface{} `json:"device_info,omitempty"`

	// EmployeeId Employee ID (required when method is manual and using employee ID lookup)
	EmployeeId *string `json:"employee_id,omitempty"`

	// Method Check-in method
	Method CheckInMethod `json:"method"`

	// ParticipantId Participant ID (required when method is manual)
	ParticipantId *openapi_types.UUID `json:"participant_id,omitempty"`

	// QrCode QR code token (required when method is qrcode)
	QrCode *string `json:"qr_code,omitempty"`
}

// CheckInResponse defines model for CheckInResponse.
type CheckInResponse struct {
	// CheckedInAt Check-in timestamp (ISO 8601)
	CheckedInAt time.Time `json:"checked_in_at"`

	// CheckedInBy User who performed the check-in
	CheckedInBy struct {
		// Id User ID
		Id openapi_types.UUID `json:"id"`

		// Name User full name
		Name string `json:"name"`
	} `json:"checked_in_by"`

	// CheckinMethod Check-in method
	CheckinMethod CheckInMethod `json:"checkin_method"`

	// DeviceInfo Device metadata captured during check-in
	DeviceInfo *map[string]interface{} `json:"device_info,omitempty"`

	// EventId Associated event ID
	EventId openapi_types.UUID `json:"event_id"`

	// Id Check-in unique identifier
	Id openapi_types.UUID `json:"id"`

	// Message Success message
	Message string `json:"message"`

	// Participant Participant basic information
	Participant struct {
		// Email Participant email
		Email openapi_types.Email `json:"email"`

		// Name Participant full name
		Name string `json:"name"`
	} `json:"participant"`

	// ParticipantId Checked-in participant ID
	ParticipantId openapi_types.UUID `json:"participant_id"`
}

// CheckInStatusResponse defines model for CheckInStatusResponse.
type CheckInStatusResponse struct {
	// CheckedIn Whether the participant has been checked in
	CheckedIn bool `json:"checked_in"`

	// Checkin Check-in details (null if not checked in)
	Checkin *struct {
		// CheckedInAt Check-in timestamp (ISO 8601)
		CheckedInAt time.Time `json:"checked_in_at"`

		// CheckedInBy User who performed the check-in
		CheckedInBy struct {
			// Id User ID
			Id openapi_types.UUID `json:"id"`

			// Name User full name
			Name string `json:"name"`
		} `json:"checked_in_by"`

		// CheckinMethod Check-in method
		CheckinMethod CheckInMethod `json:"checkin_method"`

		// DeviceInfo Device metadata
		DeviceInfo *map[string]interface{} `json:"device_info,omitempty"`

		// Id Check-in unique identifier
		Id openapi_types.UUID `json:"id"`
	} `json:"checkin"`

	// EventId Associated event ID
	EventId openapi_types.UUID `json:"event_id"`

	// EventName Event name
	EventName string `json:"event_name"`

	// ParticipantEmail Participant email
	ParticipantEmail *openapi_types.Email `json:"participant_email,omitempty"`

	// ParticipantId Participant unique identifier
	ParticipantId openapi_types.UUID `json:"participant_id"`

	// ParticipantName Participant full name
	ParticipantName string `json:"participant_name"`
}

// CreateEventRequest defines model for CreateEventRequest.
type CreateEventRequest struct {
	// Description Event description
	Description *string `json:"description,omitempty"`

	// EndDate Event end date and time (ISO 8601, must be after start_date)
	EndDate *time.Time `json:"end_date,omitempty"`

	// Location Venue or location
	Location *string `json:"location,omitempty"`

	// Name Event name
	Name string `json:"name"`

	// StartDate Event start date and time (ISO 8601)
	StartDate time.Time `json:"start_date"`

	// Status Event status
	Status EventStatus `json:"status"`

	// Timezone IANA timezone identifier
	Timezone *string `json:"timezone,omitempty"`
}

// CreateParticipantRequest defines model for CreateParticipantRequest.
type CreateParticipantRequest struct {
	// Email Email address (must be unique within the event)
	Email openapi_types.Email `json:"email"`

	// EmployeeId Employee or staff ID
	EmployeeId *string `json:"employee_id"`

	// Metadata Custom participant data (max 10KB JSON)
	Metadata *map[string]interface{} `json:"metadata"`

	// Name Participant full name
	Name string `json:"name"`

	// PaymentAmount Payment amount (decimal, 2 places)
	PaymentAmount *float64 `json:"payment_amount"`

	// PaymentDate Payment date/time (ISO 8601)
	PaymentDate *time.Time `json:"payment_date"`

	// PaymentStatus Payment status
	PaymentStatus *PaymentStatus `json:"payment_status,omitempty"`

	// Phone Phone number (preferably E.164 format)
	Phone *string `json:"phone"`

	// QrEmail Alternative email for QR code distribution
	QrEmail *openapi_types.Email `json:"qr_email"`

	// Status Participant status
	Status *ParticipantStatus `json:"status,omitempty"`
}

// Event defines model for Event.
type Event struct {
	// CheckedInCount Number of checked-in participants
	CheckedInCount *int `json:"checked_in_count,omitempty"`

	// CreatedAt Creation timestamp (ISO 8601)
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Description Event description
	Description *string `json:"description,omitempty"`

	// EndDate Event end date and time (ISO 8601, must be after start_date)
	EndDate *time.Time `json:"end_date,omitempty"`

	// Id Event unique identifier
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Location Venue or location
	Location *string `json:"location,omitempty"`

	// Name Event name
	Name string `json:"name"`

	// Organizer Event owner user details (included in detail views only)
	Organizer *struct {
		Email *openapi_types.Email `json:"email,omitempty"`
		Id    *openapi_types.UUID  `json:"id,omitempty"`
		Name  *string              `json:"name,omitempty"`
	} `json:"organizer,omitempty"`

	// OrganizerId Event owner user ID
	OrganizerId *openapi_types.UUID `json:"organizer_id,omitempty"`

	// ParticipantCount Total registered participants
	ParticipantCount *int `json:"participant_count,omitempty"`

	// StartDate Event start date and time (ISO 8601)
	StartDate time.Time `json:"start_date"`

	// Status Event status
	Status EventStatus `json:"status"`

	// Timezone IANA timezone identifier
	Timezone *string `json:"timezone,omitempty"`

	// UpdatedAt Last update timestamp (ISO 8601)
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// EventListResponse defines model for EventListResponse.
type EventListResponse struct {
	Data []Event        `json:"data"`
	Meta PaginationMeta `json:"meta"`
}

// EventStatsResponse defines model for EventStatsResponse.
type EventStatsResponse struct {
	ByStatus              *map[string]int    `json:"by_status,omitempty"`
	CheckedInParticipants int                `json:"checked_in_participants"`
	CheckinRate           float32            `json:"checkin_rate"`
	EventId               openapi_types.UUID `json:"event_id"`
	TotalParticipants     int                `json:"total_participants"`
}

// EventStatus Event status
type EventStatus string

// ImportParticipantsCSVResponse defines model for ImportParticipantsCSVResponse.
type ImportParticipantsCSVResponse struct {
	// Errors List of row-level errors
	Errors *[]struct {
		// Email Email of the failed row (if available)
		Email *string `json:"email,omitempty"`

		// Message Error message
		Message string `json:"message"`

		// Row 1-based row number in the CSV (excluding header)
		Row int `json:"row"`
	} `json:"errors,omitempty"`

	// FailedCount Number of rows that failed to import
	FailedCount int `json:"failed_count"`

	// ImportedCount Number of successfully imported participants
	ImportedCount int `json:"imported_count"`

	// SkippedCount Number of rows skipped due to duplicate email (skip_duplicates=true)
	SkippedCount int `json:"skipped_count"`

	// SkippedRows List of rows skipped due to duplicate email
	SkippedRows *[]struct {
		// Email Email of the skipped row
		Email *string `json:"email,omitempty"`

		// Reason Reason for skipping
		Reason string `json:"reason"`

		// Row 1-based row number in the CSV (excluding header)
		Row int `json:"row"`
	} `json:"skipped_rows,omitempty"`
}

// ListResponse defines model for ListResponse.
type ListResponse struct {
	// Data Array of items
	Data []map[string]interface{} `json:"data"`
	Meta PaginationMeta           `json:"meta"`
}

// LoginRequest defines model for LoginRequest.
type LoginRequest struct {
	// Email Email address
	Email openapi_types.Email `json:"email"`

	// Password User password
	Password string `json:"password"`
}

// LogoutResponse defines model for LogoutResponse.
type LogoutResponse struct {
	// Message Confirmation message
	Message string `json:"message"`
}

// PaginationMeta defines model for PaginationMeta.
type PaginationMeta struct {
	// Page Current page number
	Page int `json:"page"`

	// PerPage Items per page
	PerPage int `json:"per_page"`

	// Total Total number of items
	Total int `json:"total"`

	// TotalPages Total number of pages
	TotalPages int `json:"total_pages"`
}

// Participant defines model for Participant.
type Participant struct {
	// CheckedIn Check-in status
	CheckedIn *bool `json:"checked_in,omitempty"`

	// CheckedInAt Check-in timestamp (ISO 8601)
	CheckedInAt *time.Time `json:"checked_in_at"`

	// CreatedAt Creation timestamp (ISO 8601)
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Email Email address (unique per event)
	Email openapi_types.Email `json:"email"`

	// EmployeeId Employee or staff ID
	EmployeeId *string `json:"employee_id"`

	// EventId Associated event ID
	EventId *openapi_types.UUID `json:"event_id,omitempty"`

	// Id Participant unique identifier
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Metadata Custom participant data (max 10KB JSON, not included in list responses)
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Participant full name
	Name string `json:"name"`

	// PaymentAmount Payment amount (decimal, 2 places)
	PaymentAmount *float64 `json:"payment_amount"`

	// PaymentDate Payment date/time (ISO 8601)
	PaymentDate *time.Time `json:"payment_date"`

	// PaymentStatus Payment status
	PaymentStatus *PaymentStatus `json:"payment_status,omitempty"`

	// Phone Phone number in E.164 format
	Phone *string `json:"phone"`

	// QrCode QR code token (unique)
	QrCode *string `json:"qr_code,omitempty"`

	// QrCodeGeneratedAt QR code generation timestamp (ISO 8601)
	QrCodeGeneratedAt *time.Time `json:"qr_code_generated_at,omitempty"`

	// QrDistributionUrl Distribution URL for the QR code (only available when QR_HOSTING_BASE_URL is configured)
	QrDistributionUrl *string `json:"qr_distribution_url"`

	// QrEmail Alternative email for QR code distribution
	QrEmail *openapi_types.Email `json:"qr_email"`

	// Status Participant status
	Status ParticipantStatus `json:"status"`

	// UpdatedAt Last update timestamp (ISO 8601)
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ParticipantListResponse defines model for ParticipantListResponse.
type ParticipantListResponse struct {
	Data []Participant  `json:"data"`
	Meta PaginationMeta `json:"meta"`
}

// ParticipantStatus Participant status
type ParticipantStatus string

// PaymentStatus Payment status
type PaymentStatus string

// ProblemDetails RFC 9457 Problem Details - all fields are optional
type ProblemDetails struct {
	// Code Machine-readable error code (extension for backward compatibility)
	Code *string `json:"code,omitempty"`

	// Detail Human-readable explanation specific to this occurrence
	Detail *string `json:"detail,omitempty"`

	// Errors Validation errors (extension for validation problems)
	Errors *[]ValidationError `json:"errors,omitempty"`

	// Instance URI reference identifying the specific occurrence of the problem
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code
	Status *int `json:"status,omitempty"`

	// Title Short, human-readable summary of the problem type
	Title *string `json:"title,omitempty"`

	// Type URI reference identifying the problem type
	Type *string `json:"type,omitempty"`
}

// RefreshTokenRequest defines model for RefreshTokenRequest.
type RefreshTokenRequest struct {
	// RefreshToken Valid refresh token obtained from login or previous refresh
	RefreshToken string `json:"refresh_token"`
}

// RegisterRequest defines model for RegisterRequest.
type RegisterRequest struct {
	// Email Email address (must be unique)
	Email openapi_types.Email `json:"email"`

	// Name Full name
	Name string `json:"name"`

	// Password Password (minimum 8 characters)
	Password string `json:"password"`

	// Role User role
	Role UserRole `json:"role"`
}

// UpdateEventRequest defines model for UpdateEventRequest.
type UpdateEventRequest struct {
	// Description Event description
	Description *string `json:"description,omitempty"`

	// EndDate Event end date and time
	EndDate *time.Time `json:"end_date,omitempty"`

	// Location Venue or location
	Location *string `json:"location,omitempty"`

	// Name Event name
	Name *string `json:"name,omitempty"`

	// StartDate Event start date and time
	StartDate *time.Time `json:"start_date,omitempty"`

	// Status Event status
	Status *EventStatus `json:"status,omitempty"`

	// Timezone IANA timezone identifier
	Timezone *string `json:"timezone,omitempty"`
}

// UpdateParticipantRequest defines model for UpdateParticipantRequest.
type UpdateParticipantRequest struct {
	// Email Email address (must be unique within the event)
	Email *openapi_types.Email `json:"email,omitempty"`

	// EmployeeId Employee or staff ID
	EmployeeId *string `json:"employee_id"`

	// Metadata Custom participant data (max 10KB JSON)
	Metadata *map[string]interface{} `json:"metadata"`

	// Name Participant full name
	Name *string `json:"name,omitempty"`

	// PaymentAmount Payment amount (decimal, 2 places)
	PaymentAmount *float64 `json:"payment_amount"`

	// PaymentDate Payment date/time (ISO 8601)
	PaymentDate *time.Time `json:"payment_date"`

	// PaymentStatus Payment status
	PaymentStatus *PaymentStatus `json:"payment_status,omitempty"`

	// Phone Phone number (preferably E.164 format)
	Phone *string `json:"phone"`

	// QrEmail Alternative email for QR code distribution
	QrEmail *openapi_types.Email `json:"qr_email"`

	// Status Participant status
	Status *ParticipantStatus `json:"status,omitempty"`
}

// User defines model for User.
type User struct {
	// CreatedAt Creation timestamp (ISO 8601)
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Email Email address (unique)
	Email openapi_types.Email `json:"email"`

	// Id User unique identifier
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Name Full name
	Name string `json:"name"`

	// Role User role
	Role UserRole `json:"role"`

	// UpdatedAt Last update timestamp (ISO 8601)
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// UserRole User role
type UserRole string

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Field Field name that caused the error
	Field string `json:"field"`

	// Message Field-specific error message
	Message string `json:"message"`
}

// CheckInIDParam defines model for CheckInIDParam.
type CheckInIDParam = openapi_types.UUID

// EventIDParam defines model for EventIDParam.
type EventIDParam = openapi_types.UUID

// OrderParam Sort order (ascending or descending)
type OrderParam string

// PageParam defines model for PageParam.
type PageParam = int

// ParticipantIDParam defines model for ParticipantIDParam.
type ParticipantIDParam = openapi_types.UUID

// PerPageParam defines model for PerPageParam.
type PerPageParam = int

// SortParam defines model for SortParam.
type SortParam = string

// BadRequest RFC 9457 Problem Details - all fields are optional
type BadRequest = ProblemDetails

// Conflict RFC 9457 Problem Details - all fields are optional
type Conflict = ProblemDetails

// Forbidden RFC 9457 Problem Details - all fields are optional
type Forbidden = ProblemDetails

// InternalError RFC 9457 Problem Details - all fields are optional
type InternalError = ProblemDetails

// NotFound RFC 9457 Problem Details - all fields are optional
type NotFound = ProblemDetails

// RateLimitExceeded RFC 9457 Problem Details - all fields are optional
type RateLimitExceeded = ProblemDetails

// ServiceUnavailable RFC 9457 Problem Details - all fields are optional
type ServiceUnavailable = ProblemDetails

// Unauthorized RFC 9457 Problem Details - all fields are optional
type Unauthorized = ProblemDetails

// ValidationErrorResponse RFC 9457 Problem Details - all fields are optional
type ValidationErrorResponse = ProblemDetails

// GetEventsParams defines parameters for GetEvents.
type GetEventsParams struct {
	// Page Page number (min 1)
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Items per page (min 1, max 100)
	PerPage *PerPageParam `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Sort Sort field name
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sort order (asc or desc)
	Order *GetEventsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Name Filter by event name (partial match)
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Status Filter by event status
	Status *EventStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetEventsParamsOrder defines parameters for GetEvents.
type GetEventsParamsOrder string

// ListCheckInsParams defines parameters for ListCheckIns.
type ListCheckInsParams struct {
	// Page Page number (min 1)
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Items per page (min 1, max 100)
	PerPage *PerPageParam `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Sort Sort field name
	Sort *ListCheckInsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sort order (asc or desc)
	Order *ListCheckInsParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// ListCheckInsParamsSort defines parameters for ListCheckIns.
type ListCheckInsParamsSort string

// ListCheckInsParamsOrder defines parameters for ListCheckIns.
type ListCheckInsParamsOrder string

// ListParticipantsParams defines parameters for ListParticipants.
type ListParticipantsParams struct {
	// Page Page number (min 1)
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Items per page (min 1, max 100)
	PerPage *PerPageParam `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Sort Sort field name
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sort order (asc or desc)
	Order *ListParticipantsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Search Search by name, email, or employee_id (partial match)
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Status Filter by participant status
	Status *ParticipantStatus `form:"status,omitempty" json:"status,omitempty"`
}

// ListParticipantsParamsOrder defines parameters for ListParticipants.
type ListParticipantsParamsOrder string

// ImportParticipantsCSVMultipartBody defines parameters for ImportParticipantsCSV.
type ImportParticipantsCSVMultipartBody struct {
	// File CSV file (max 10MB). Required columns: name, email
	File openapi_types.File `json:"file"`
}

// ImportParticipantsCSVParams defines parameters for ImportParticipantsCSV.
type ImportParticipantsCSVParams struct {
	// SkipDuplicates When true, rows with duplicate email are skipped instead of treated as errors
	SkipDuplicates *bool `form:"skip_duplicates,omitempty" json:"skip_duplicates,omitempty"`
}

// DownloadParticipantQRCodeParams defines parameters for DownloadParticipantQRCode.
type DownloadParticipantQRCodeParams struct {
	// Format QR code format
	Format *DownloadParticipantQRCodeParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// Size QR code size in pixels (PNG only, min 100, max 2000)
	Size *int `form:"size,omitempty" json:"size,omitempty"`
}

// DownloadParticipantQRCodeParamsFormat defines parameters for DownloadParticipantQRCode.
type DownloadParticipantQRCodeParamsFormat string

// LoginUserJSONRequestBody defines body for LoginUser for application/json ContentType.
type LoginUserJSONRequestBody = LoginRequest

// RefreshTokenJSONRequestBody defines body for RefreshToken for application/json ContentType.
type RefreshTokenJSONRequestBody = RefreshTokenRequest

// RegisterUserJSONRequestBody defines body for RegisterUser for application/json ContentType.
type RegisterUserJSONRequestBody = RegisterRequest

// PostEventsJSONRequestBody defines body for PostEvents for application/json ContentType.
type PostEventsJSONRequestBody = CreateEventRequest

// PutEventsIdJSONRequestBody defines body for PutEventsId for application/json ContentType.
type PutEventsIdJSONRequestBody = UpdateEventRequest

// CheckInParticipantJSONRequestBody defines body for CheckInParticipant for application/json ContentType.
type CheckInParticipantJSONRequestBody = CheckInRequest

// CreateParticipantJSONRequestBody defines body for CreateParticipant for application/json ContentType.
type CreateParticipantJSONRequestBody = CreateParticipantRequest

// BulkCreateParticipantsJSONRequestBody defines body for BulkCreateParticipants for application/json ContentType.
type BulkCreateParticipantsJSONRequestBody = BulkCreateParticipantsRequest

// ImportParticipantsCSVMultipartRequestBody defines body for ImportParticipantsCSV for multipart/form-data ContentType.
type ImportParticipantsCSVMultipartRequestBody ImportParticipantsCSVMultipartBody

// UpdateParticipantJSONRequestBody defines body for UpdateParticipant for application/json ContentType.
type UpdateParticipantJSONRequestBody = UpdateParticipantRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Authenticate user
	// (POST /auth/login)
	LoginUser(c *gin.Context)
	// Logout user
	// (POST /auth/logout)
	LogoutUser(c *gin.Context)
	// Refresh access token
	// (POST /auth/refresh)
	RefreshToken(c *gin.Context)
	// Register a new user
	// (POST /auth/register)
	RegisterUser(c *gin.Context)
	// List events
	// (GET /events)
	GetEvents(c *gin.Context, params GetEventsParams)
	// Create event
	// (POST /events)
	PostEvents(c *gin.Context)
	// Delete event
	// (DELETE /events/{id})
	DeleteEventsId(c *gin.Context, id EventIDParam)
	// Get event details
	// (GET /events/{id})
	GetEventsId(c *gin.Context, id EventIDParam)
	// Update event
	// (PUT /events/{id})
	PutEventsId(c *gin.Context, id EventIDParam)
	// Check in a participant
	// (POST /events/{id}/checkin)
	CheckInParticipant(c *gin.Context, id EventIDParam)
	// List check-ins for an event
	// (GET /events/{id}/checkins)
	ListCheckIns(c *gin.Context, id EventIDParam, params ListCheckInsParams)
	// Cancel a check-in
	// (DELETE /events/{id}/checkins/{cid})
	CancelCheckIn(c *gin.Context, id EventIDParam, cid openapi_types.UUID)
	// List participants for an event
	// (GET /events/{id}/participants)
	ListParticipants(c *gin.Context, id EventIDParam, params ListParticipantsParams)
	// Add a participant to an event
	// (POST /events/{id}/participants)
	CreateParticipant(c *gin.Context, id EventIDParam)
	// Bulk import participants
	// (POST /events/{id}/participants/bulk)
	BulkCreateParticipants(c *gin.Context, id EventIDParam)
	// Import participants from CSV
	// (POST /events/{id}/participants/import)
	ImportParticipantsCSV(c *gin.Context, id EventIDParam, params ImportParticipantsCSVParams)
	// Get event statistics
	// (GET /events/{id}/stats)
	GetEventsIdStats(c *gin.Context, id EventIDParam)
	// Basic health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Liveness probe
	// (GET /health/live)
	GetHealthLive(c *gin.Context)
	// Readiness probe
	// (GET /health/ready)
	GetHealthReady(c *gin.Context)
	// Delete a participant
	// (DELETE /participants/{id})
	DeleteParticipant(c *gin.Context, id ParticipantIDParam)
	// Get participant details
	// (GET /participants/{id})
	GetParticipant(c *gin.Context, id ParticipantIDParam)
	// Update participant information
	// (PUT /participants/{id})
	UpdateParticipant(c *gin.Context, id ParticipantIDParam)
	// Get participant check-in status
	// (GET /participants/{id}/checkin-status)
	GetCheckInStatus(c *gin.Context, id ParticipantIDParam)
	// Download participant QR code
	// (GET /participants/{id}/qrcode)
	DownloadParticipantQRCode(c *gin.Context, id ParticipantIDParam, params DownloadParticipantQRCodeParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// LoginUser operation middleware
func (siw *ServerInterfaceWrapper) LoginUser(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LoginUser(c)
}

// LogoutUser operation middleware
func (siw *ServerInterfaceWrapper) LogoutUser(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LogoutUser(c)
}

// RefreshToken operation middleware
func (siw *ServerInterfaceWrapper) RefreshToken(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RefreshToken(c)
}

// RegisterUser operation middleware
func (siw *ServerInterfaceWrapper) RegisterUser(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RegisterUser(c)
}

// GetEvents operation middleware
func (siw *ServerInterfaceWrapper) GetEvents(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEventsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter page: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", c.Request.URL.Query(), &params.PerPage)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter per_page: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", c.Request.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sort: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", c.Request.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter order: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", c.Request.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", c.Request.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter status: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetEvents(c, params)
}

// PostEvents operation middleware
func (siw *ServerInterfaceWrapper) PostEvents(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostEvents(c)
}

// DeleteEventsId operation middleware
func (siw *ServerInterfaceWrapper) DeleteEventsId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id EventIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteEventsId(c, id)
}

// GetEventsId operation middleware
func (siw *ServerInterfaceWrapper) GetEventsId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id EventIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetEventsId(c, id)
}

// PutEventsId operation middleware
func (siw *ServerInterfaceWrapper) PutEventsId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id EventIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PutEventsId(c, id)
}

// CheckInParticipant operation middleware
func (siw *ServerInterfaceWrapper) CheckInParticipant(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id EventIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CheckInParticipant(c, id)
}

// ListCheckIns operation middleware
func (siw *ServerInterfaceWrapper) ListCheckIns(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id EventIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCheckInsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter page: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", c.Request.URL.Query(), &params.PerPage)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter per_page: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", c.Request.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sort: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", c.Request.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter order: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListCheckIns(c, id, params)
}

// CancelCheckIn operation middleware
func (siw *ServerInterfaceWrapper) CancelCheckIn(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id EventIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "cid" -------------
	var cid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "cid", c.Param("cid"), &cid, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter cid: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CancelCheckIn(c, id, cid)
}

// ListParticipants operation middleware
func (siw *ServerInterfaceWrapper) ListParticipants(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id EventIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListParticipantsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter page: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", c.Request.URL.Query(), &params.PerPage)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter per_page: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", c.Request.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sort: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", c.Request.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter order: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", c.Request.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter search: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", c.Request.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter status: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListParticipants(c, id, params)
}

// CreateParticipant operation middleware
func (siw *ServerInterfaceWrapper) CreateParticipant(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id EventIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateParticipant(c, id)
}

// BulkCreateParticipants operation middleware
func (siw *ServerInterfaceWrapper) BulkCreateParticipants(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id EventIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.BulkCreateParticipants(c, id)
}

// ImportParticipantsCSV operation middleware
func (siw *ServerInterfaceWrapper) ImportParticipantsCSV(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id EventIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ImportParticipantsCSVParams

	// ------------- Optional query parameter "skip_duplicates" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip_duplicates", c.Request.URL.Query(), &params.SkipDuplicates)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter skip_duplicates: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ImportParticipantsCSV(c, id, params)
}

// GetEventsIdStats operation middleware
func (siw *ServerInterfaceWrapper) GetEventsIdStats(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id EventIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetEventsIdStats(c, id)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// GetHealthLive operation middleware
func (siw *ServerInterfaceWrapper) GetHealthLive(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealthLive(c)
}

// GetHealthReady operation middleware
func (siw *ServerInterfaceWrapper) GetHealthReady(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealthReady(c)
}

// DeleteParticipant operation middleware
func (siw *ServerInterfaceWrapper) DeleteParticipant(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id ParticipantIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteParticipant(c, id)
}

// GetParticipant operation middleware
func (siw *ServerInterfaceWrapper) GetParticipant(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id ParticipantIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetParticipant(c, id)
}

// UpdateParticipant operation middleware
func (siw *ServerInterfaceWrapper) UpdateParticipant(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id ParticipantIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateParticipant(c, id)
}

// GetCheckInStatus operation middleware
func (siw *ServerInterfaceWrapper) GetCheckInStatus(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id ParticipantIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetCheckInStatus(c, id)
}

// DownloadParticipantQRCode operation middleware
func (siw *ServerInterfaceWrapper) DownloadParticipantQRCode(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id ParticipantIDParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadParticipantQRCodeParams

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", c.Request.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter format: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", c.Request.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter size: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DownloadParticipantQRCode(c, id, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/auth/login", wrapper.LoginUser)
	router.POST(options.BaseURL+"/auth/logout", wrapper.LogoutUser)
	router.POST(options.BaseURL+"/auth/refresh", wrapper.RefreshToken)
	router.POST(options.BaseURL+"/auth/register", wrapper.RegisterUser)
	router.GET(options.BaseURL+"/events", wrapper.GetEvents)
	router.POST(options.BaseURL+"/events", wrapper.PostEvents)
	router.DELETE(options.BaseURL+"/events/:id", wrapper.DeleteEventsId)
	router.GET(options.BaseURL+"/events/:id", wrapper.GetEventsId)
	router.PUT(options.BaseURL+"/events/:id", wrapper.PutEventsId)
	router.POST(options.BaseURL+"/events/:id/checkin", wrapper.CheckInParticipant)
	router.GET(options.BaseURL+"/events/:id/checkins", wrapper.ListCheckIns)
	router.DELETE(options.BaseURL+"/events/:id/checkins/:cid", wrapper.CancelCheckIn)
	router.GET(options.BaseURL+"/events/:id/participants", wrapper.ListParticipants)
	router.POST(options.BaseURL+"/events/:id/participants", wrapper.CreateParticipant)
	router.POST(options.BaseURL+"/events/:id/participants/bulk", wrapper.BulkCreateParticipants)
	router.POST(options.BaseURL+"/events/:id/participants/import", wrapper.ImportParticipantsCSV)
	router.GET(options.BaseURL+"/events/:id/stats", wrapper.GetEventsIdStats)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.GET(options.BaseURL+"/health/live", wrapper.GetHealthLive)
	router.GET(options.BaseURL+"/health/ready", wrapper.GetHealthReady)
	router.DELETE(options.BaseURL+"/participants/:id", wrapper.DeleteParticipant)
	router.GET(options.BaseURL+"/participants/:id", wrapper.GetParticipant)
	router.PUT(options.BaseURL+"/participants/:id", wrapper.UpdateParticipant)
	router.GET(options.BaseURL+"/participants/:id/checkin-status", wrapper.GetCheckInStatus)
	router.GET(options.BaseURL+"/participants/:id/qrcode", wrapper.DownloadParticipantQRCode)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9+XLbtvbwq2B0v5k6/cmy5CVxPHNnrmI7rVJvseR0S0aFSEhCQgIMQNpWOnn3b7CR",
	"AAlqsWUnafNPG4skloOz4ax/NwIaJ5QgkvLGwd+NBDIYoxQx+dfhFAUfeqR3dCF+Fr+EiAcMJymmpHGg",
	"nm9iAjKCP2YI4BCRFI8xYmDj6qp39KTRbGDxYgLTaaPZIDBGjYMGDhvNBkMfM8xQ2DhIWYaaDR5MUQzF",
	"HOgWxkkkXtzfb6P93XZ7E20/H23udsLdTfis83Rzd/fp07293d12u91uNBtjymKYNg4aWSaHTmeJ+Jqn",
	"DJNJ4/PnZuP4GpG0dhvy6UPtYW9vTXs4ZyFiNTvoU5YCKl4AG5AHgDIgXsjX/jFDbFYsXr7ZsNcbojHM",
	"IjG/+K7RnD8+IiEmEzOL+kvMhUgWNw7+bMB8iMa7pgULPXZ1bxdwgmq2Jh4BksUjMXeMCejU7SqBE+Tf",
	"VMdaRKfZiDHBsVhpJ18LJimaIKYXw1Ic4ATOQRnrnYdCnGfP1oQ4FwJtauHbS1HMQYIYEPDTIG6CGN6C",
	"TrtdC2vEhvXw3m5bABd/xPBWQ7zdXgh/gWzz8HyMURQCuRD/4jhlaQ12BwzBFIVDKF4oYO38XIbgZ3Fe",
	"PKGEI8kVX8DwEn3MEE/FXwElKSLynzBJIhxAsdat91ws2DpP8WYoxn3RPRpeHr++Ou4PJJGkEEeNg8Zg",
	"igBTw4KAZmKHNAUjBDISIsZTSkMQZgikFGByDSMcAj4jKbyVQOApJIEYfQsmeOu6s4WuJUtvNngK04w3",
	"DnYF5FOcyv2+gCEwe8g3PE3ThB9siRFa6NNHhkkroPFWwugoQjHfGsFwU6+w8dkG7/9jaNw4aPxnq5Al",
	"W+op37pQXx/JbXIFTfdMxVrMxjfzvWGSZILlgBhGAsVR/pKY+5CScYSDux3A4fnZy5PeoQP9Lkgsir7B",
	"6RSkU8wBiiGOAOYARgzBcAYYmmCeIoZCMKZMvyRgPe8YtjrbO1vWBO65PC/OJd/X0ocSmC/WeCKXiNOM",
	"BQiYwcFGmCnIoqb4kacMYpKCa0wjCe0nYvqXlI1wGCJyp1N5eX75ond0dHxmH8vvNAMhlZQwhddIsKkY",
	"c44pEXQAgwBxrs6A6TUvOgYH8jsF5IvFLw36cf7JGmHfIzwbj3GAhUpSbJeL/SaICVJQG4aB/OJzs9Ej",
	"KWIERseMUXYn2PfOBseXZ92T4fHl5fmlQxdCt0O3CQpSFAIkZgA0CDLGUNgCFxGCHIGUzQCcQExABFPE",
	"WktypD2bI5lNgD5i14gBtZmlzwLrzzflEtd7IHphXC0sn+CMpi9pRsI7QfzsfDB8eX51dlQjAgSwpVZ6",
	"A7lE/7GcahXk3i2AmxP0GU3BSz3SkpAlNN1Uk68RqO5ODe2WNvu52biEKTrBMU6PbwOEQnQ3YA/Oz4en",
	"3bPfjdjt20AXU4BIzAGQnmRFxIZZOt2K6AQTG/7bFlsfUApOIZkZmcuXB39K6WYMycxIXr5WRl/de6PZ",
	"mCIY6gvgb5v5CWzK/1ZVslOl2pnjVKrkDSYhvWl4FVupAnrUPnuuSyF3iVC/KvPlj4oZMQGSI0nJXT/x",
	"MtNy5NniFcG3IMUx4imME3AzRURDjYkPeM0+n+483Xm2ve/drtRzEbvGAboi8BriCI4Mzq6I3f3jyze9",
	"w+Ph1Vn3Tbd30n1xclxmKlzNJPSYFMUJZZDhaAayYuYVUX6KYJROt6RK5HB0S6Lq7QF7f0ujvV7xprXE",
	"dSK+WVsNNMRUV0TQNWX40x25ztVZ92rw8/ll749jh8v3tIZLGUC3ibgFAjGTuDyqMUFKP0g9ZDm1vlOA",
	"3Fnz0rDO7K/WCOSuuytz5xUblzs0ur6Y8434h3xPCv5Lfd+6E+DfdE96R91B7/ysqs+cEyQvFZQhcJ3P",
	"qYQ6zzUbcTeUvzQO/vy7Ie+b8kIIWToMYSrwOEaci/vvQaMvfgbiZxBnXF7ZMAHpFIFxlmZMIFMxhr61",
	"Fl+fwVjSZW4R+PzuDve5AnyrKk4FENavOmlpZwN6DHEkNpnPIsWMwBT7yBNGE8RSrO7bSs0fKqqoMOdX",
	"vw7yi4DEKnEt6170SkTlXPfR7NV09FOAz/Gr3tWnXucM93iPXO4Fh72nvQ/Jb28OXz1vodmrT+GvPXyO",
	"e52zwYvo/Oj1zelhJzp9H+GTwevbP45ep78Pgtsz3G6fHf2+fTa4ap8ddW9Oj7r45PDVbLR9G/XeUzza",
	"eUV+/3UvQfGbWQ/f4D9+m9703tPbs/evb84HHzqn77s349ctOAo62zshGu/uPZ1M8bP95+8/RO3Odkzo",
	"zu5e8pE9fbbP0+x5u3N9c7u9szv7VDVViD0KjsKHmDh2j+cCWUrUacNMfqaZD44lAnMUUBJysPG83Qb/",
	"BZ09EGOSpYg/sUH53Cfdmg2Gxgzxad2ZXarH1oHRUaqlOkE3znnyRz+5NvrthTy5IH4TB/GbT/Cwx3vx",
	"m10xyeng9/bp0Ye9s0Hv5vTnduv22fv9Xz7+tv37zh+7cG/0NHgW7qPn4/akM93GO+93P+xFT+NnZJ8+",
	"T9q+A5N7HKqfbUPVCwSZtNGWFGcJMfE62IDRDZxx8Fa/+7bhnEwxQmXOjCO2iLqvuNaPClPlny4llk/Z",
	"2YuDiXrGd/lS6Og9UiaLF1n04VAa3yyLKrfMay4rcGwoFbTqMgZngI5tW468OCvzHtjQRs22A6g//25I",
	"K0/joPGeTsn/9APBJguT4is6JeCIIosBC8E0xiyWQtMaAxJUGgPFSURnCA2xEAHHpxftdscaGhIE+jGW",
	"RmLf4EIgpCjmi46sAsfLwmAWw9ueGkPsX5pgzd/5qUABvsqZOyBf5Qjr2LmxtQY0Ix5l+0yZ+sunyDOJ",
	"e+Msimb6PEOHEe1bdmUvTzISvTzhCeapmE7rAIIbKSkFSha7/BDc/eiDrziVpOWQjpUmUBnQIdXculZC",
	"nNy2r+bw8Xtj8ylNLg01Rsuwp1LLWsaaWZkLkxDdehwI4mej8lCGJ5jAKLfoKqSyVrDnvYXZGKfmaeab",
	"Vnv0oZ6LuM2GAvOKmJVOYWoOKOcV9oq3F2HWfK5k8MuHwbUoNlfxsrDo8wLqdYmtBKHmYuLWHmAPFYsH",
	"KBxiMoTpHM9wcW3e6PXPwf7TdqcJtJgDZ+e/bjxxpdZ2e3tvs7O92dkbtJ8fdPYO2u0/bEoQevamGFTK",
	"Hxiek2hmvGgVjLUWOZp57vUcMXAzzQ2rKASBXreAjbNfHLreuadP1+GdM0LAHrmfwvEYSPnr8+bVbLo4",
	"MrkFTIYxSqc0XCg01AGfqpelCi9uxkNMxlQq32GIBbhgdGHBQ03tQvNIfghilMIQplBJ271fXoBX/fMz",
	"55DlRW54jRhXX3Za7Va7kU+tdxTTEZYmAyrkIT7vW8he7FZyq6E6nZI2wDkNMCxMqb0jB9Pu6JhfiHS+",
	"tdQHSjhLumO8w8IlWWQ+rF0eCsUCbTdYCWB3dEgvWF2Z+Uupbg61svRmifFU0H0OExOMeI5aosaZw8AN",
	"b+DKP2hDSlCL2LW6aNYoCvdgmXfnkWvgiUKuL+CLnjFKyLNufumZUUhWExawAjst4Z4c4N3Xy1ddRvpN",
	"sMyvgEXOY4nzo3tc0l5K9bc/z5XYfAeeC+ISer59haxeNdTD8nEVN80s0v6FGgHhpyp7H37icu6u84nL",
	"fCt36KOvLyqk7imU3IudV0TlLHcpkVW+2SRQXKsUJBbdDsybpyiF1QuBEXPOmHOk5mnO7grj1EcmTe3N",
	"OhLWGysCAvMPYkgyGLlRgfnDClrqJVjmoCrrMwx1CU5oOHcx40c21E4DdJ0ODXsbJiwdGkQa2oZZeRQO",
	"C1ibuizu30GuAjAoTmniKtFNQBM1+AJ1ettWp2MaokgA4WJKCQKdPXDB6BLatvinPeqz1p5fnCzJmsBG",
	"7gGSHlR1GgBzoJACQBKCjItdI+uriNIPWfLEz9hieHuCyCSdFpGF+d8efLqj6F7EmS4cdrRon08egF9Z",
	"mFxe3OtLIB5oW3vt2hRJuGtbkiacY9hbeAwlhrRYb1+gs3/XqL9r1PdjvQFM0kzQRJiJXdhHsyyT/a6A",
	"r7qE3AVeifFWdlKv9drmtK49VdEgwOReyv4Ichx8JSr/d538C+rkBX7OEUx96axbRjxVIffrFKVTxKQo",
	"sEE3hRyMECIuRuewdO5vI0ojBInFSudQtQqB4WBDXAYBHstAy2KSJ55r4ndh+13Yfn3mqy8uu3xgX8OV",
	"/8trBWoFfhRVOZIV9BygYAoOKRkjhkiAgKDtBRJ4+HgidJWL23zMWdc1zV7RIwj4eUJxaAYuZKiFADYK",
	"+2Wg9CxLtKgN13F25sco+zd7k10ibQIpCqaERnQyk8lICssqN862D5lJqGI1ayZGJFRBm5CEKujNclCb",
	"QE44ThEDReBnrSDr7B+02ysJsogG0A+YN4hkMko1f8URCJCAlwySAPOACtITu8GUgENEUom15dv4kkJo",
	"NQq3Jtne21toebFiZ2sm5kUYbfVE5ikQK8LdRFjNl39yTUq/k0IIx+gTJZ7F97pnXWAe13GPbowYDuDW",
	"CeXDLpmgCPFldXMn6FivvZ4cPcFfq8UrwTBk4vK1YShAs8UbnE51iI9kEk9WZs4rIsxyVkUqiXM8rvV8",
	"lGdd6AnJ9ZSVlJzDjKc0dhT5Igai0/YHQQi0g2RW0BhLGs1GiFEK2WzIkFiUTPLjAh+u0UQ8wFCyY0bV",
	"PskEE6SikGq2VqDIWuTNiseYwFksZAqM/TFZF+o5UM/BRogCHMOoCbZBEsGgFG3c2WvbZE4zlVNiR2fV",
	"QEEVELBX5OdFZj3i6dZiHtTZbO8POtsHO3N50EKkM2tajjfpNRbcKZl6WZOy95vSCQlDY8TgKJqB41bn",
	"6S5QS3V39X+dzb29vc22yiV0BMkS2/jI6nS7biSTKFN8jXRK9ZgyYEzTIRZjjLKKrBN8pXVD2YdVmcvC",
	"pS4L6Zw2DLRXtaBIQTLXcr0wWjHwGlmcuPi2SwQ1ITdWyKJV8KB6mRLPTCrAEjd5RQTtBYJ4YZDSd2Wx",
	"XmnxCkF/1ZpHiXH7dymvlE0gwZ8Qq5uX3hDEQMYRK8xsmARRFkrbmv4RXGN0wwEl0exJvV3Z4n7VbITF",
	"V97Hi1O1UiLuEKWaw3RYj9sWWNdjjlspULKGLw9oKsPb88D5Op4slZXVuPI/6pZkgkW6HMOtAf0wo5WA",
	"kfVdnpqNLAlrJdoJ5ClQLzyqUPNZCh3Eb656zZMQLweywig6H8tEpnmH5Xz1uVmx1ehLz1IpCEqr8SUf",
	"lFb8zqxZYMkcV8loZim//nvX376cHus2BUmAokhAeq9ppU8d7AspgkgqtU9Blp/rrONKHytnc+RzPNvz",
	"alLasss01RY6WUt8kKPNOKJ2daniQmLbfddv000Fu6rfU10xBhttLQOhZ7R62JVgU4vO/fzgazieeFrE",
	"koUMjmXuSjaKMJ/KNDBKJlRsuCkv1RFSyWEFSjjxZvaHFXj14kSVH8v3cdh/U4+3i5LKGL3ZjNA1inR6",
	"2VrSyBi9ARt4DPJ6BS4DG8GwpDYs73yvTxyrJHEfSHXLyV33zMToTXWWzuYIcr0RfT/VxqXD/huwgW6F",
	"6oTJBKhSJM72dhbiK5MFQOb5b++aN8boTSVfDEuEadRUGPTmi6lPlpnQiXEwn9VrHLsLkyD5B5wkS29V",
	"v23qzuVpivoOvyGeD/Nf+X+FEHyyUuqcWY+Ybi4VLVrM/QjLjK1Qx0nMXERKDEFOvTnu4ndp55CjK/ZU",
	"l4iJbjFP+RJJmGunp70l6UnvczE5lZUeF9nLKFgiPt/w8/N2jN5SkwqukMJCjoXMIEYpvGeQtXZ0y5G8",
	"O6ITTO5loHdQKVcp7+Ag5fyGsrogiPyxc4dHQcbQxf84v2nLR/k01uvzFWGznvyDGiDRbM7B18qwQ6X7",
	"KVnlE2V9m6tGdDJBIaBZ2lgcqlovUkoY4alc4F2qLluVFEVuG8vXqm0WZVgXlHVt3Lkeq9b56u7BJBcY",
	"htDq7781Q8sN8MUTqNesCRYIu4orXILBKlyrNuauwn+0TvTg8jFeeVRKocOatY9hxFHt/bEc2PXYUVdl",
	"8/niROuvz5y8nJtTm08Fnfyz/ZrfRp70gwfkLFzVQ/p/mzLm0jYMR0LBzYtLP6x/+N/jD/7uA/b7gDFx",
	"XL9zPL/LuHqXSjdSRHzHtKKFxKpXMZwgglitADJL0m89vij6yIa2i3uYMY9gOrLeAFeXJ/ouiHIv+QYl",
	"0ayw+agErteXw5/P+4Pe2U/DF93+8VB8iLl0f+JJxlDobstUA/zIWpZY2/rItv747Y/2b5+uOqc/Xe2e",
	"HXVvftt5MQtf7u+cfdL10162Wi2HoTJ8F03h3xAj8O04IyzTrhPJkG++oPQFmvGX90ksKovk8UxUz87x",
	"XBVeg+YcIVkxUNufFX4I2xwthgsiTMqWafvtCjq6LN9ZaEYSiEPPKpUgq6wwf1/+z1lC/qg6v1vvs2rw",
	"enkInu/uPQP6RaDfBJsARpHq2sEBZCjPYq44wf0i5RQGU0zQpsBvyflUGXrFFNFtiohsCCC4xQgGH24g",
	"C4HUnVI8whFOZy5J2aXXPUEoqZc5/ZzFkFgruE0iqK77gCcowGMcgJQq252uIqtiT6xYhCWqu/vru3mA",
	"/aZSu7YECctcb2q9Plm2wFipGK/PSFZUqK0Yji57QIaayYALrb3PMJkoQ6sBVgEkY4PVy3Rg5i1xb4ug",
	"zXyq+V7s0mkOBheaKoCuBJDPqQrnV00VqtJuJVlxSlnaBFMXPXgWx5DNSjsDeWVMs715dfktF15eHHR5",
	"ONdOuXy5/4qsr8qTikDQhV1lldJa++aC4rAS+wBzSsSq8rAoBGNGYyBr7Ys7csLQNaYZN2//k0vFlo3y",
	"DhDfec9ChaisNRD8yd0MzyveEv0305f+22gRhjRnlu2VjN8X+onshiW7G+yDYAoZDFLE3CvocubwOSvb",
	"9zp5FK9ZVKD3Ury30Lie63ZyWB+qXEltdM25PA8QdflAyTXriDl8jHyYrzDHZQmZoJDre2bKPzkzxTE6",
	"9hHBlIHvuSnfc1O+56Y8cm5KlfvqWv/+GuzfqL/OXUbG166A1paF+DLpFuvXhzv31jq/ISOnxoGFWrDZ",
	"m//o5XdWj+MwlvVEiuQQSbnjsWtPsx9XIF42tFToVLcNqpx83gFXRSMGMOO60gnS7X+se3Bd8E9tAI0c",
	"fjM31aDamFDTyipnmzFcHEWj9jQvQFPwQHGrwumsL/BOh4jLfibdTKCv+eulQZFXvw4q5s9KZyDXiiCg",
	"pSwJiIQJxSRtvSU95Zw14XNd3RhLMUQVPQcgPwB/qe4q4G3Wbu8Ecnj5T/TXW2LawclIjlITlmmaJqpV",
	"kqmkElCSQtXJ1rQQ4VmSUJb+r7DPFN1C0KfXl5iAvnqlkjenLw8xJHCClPZCQinM8liUGU9RDLoXvbfk",
	"LfnPf8D5NWLXGN2IPwcCg9QM3Yue7HsrTakMTRHhUkKWx08imOqupFBc2YRo4yBHewH7g7dkE6gEdbkc",
	"9bUaiotnxlThNmYQr+biN/eDyQ8GDAYfrILc4lXjBAQMCdDI907VTDKFCAYyxFC97DaH0pDoVn4U8BCA",
	"yDjiQOCTPnbVmUgqCu5ILWAwSKCPaXNWi0sHYpK//vrrLXGeHgAHvey2OwrL9EdvyY8/qo5Ag1mC+MGP",
	"P4pN685O8sEBUOY0sdKihZOCuTKwVV57BkI44wYkF73Nl5jxFByhaxTRRJy5ggzm4DxBRIDHsAptEEfs",
	"GnEAudz2jz/2MZlECPSVqZOOwYBl6RRs9Pvngyc//qigGEUS0IIaGAxS3npLdCdYcehNEESyI27/6Bfe",
	"lCdoGbi1cJK+hdwVbIgc89LyVInRvyhM8KYYe4LIXy29XdkQU/aCxGQifhNryvtMivHF2Juy+aMK/06Y",
	"ogg4yjhqAaujplVFThCSHfZhIj40FnBJIH9Vmm3+dQDmdNesfJN3xvzrACzTJdMzAEdi0kX9LgVgXlKT",
	"64hCCRT1Bm8CjhTy/+kAE4Q0yGLlGaPk3UZrK6QBl/Z98fVQfd2KwyctyUEjHCDtStSc77QnWLz0nedW",
	"bJogokzoLcomW/ojviXeLYz2jYKlNZqNct+Jz82GGAYmuHHQ2Gm1WzvSeJZOpdSxu7sK8Uy5R9uxGIdA",
	"fMVvZJMAJRkFvhpzHAgYktojjBQrYijNGFHsRfGVlk3ZJ3iMxFl4ibsgadWnTTdte+IhcEXWYONpe3ff",
	"eVNM1dfiVk9SYLGL5CMmGPGYCjqGaQqDD5KVvFRYANMUxYmmEx1WK8Pf9eAgpgSnlEnS2gTGyKrelyYH",
	"hkwF4FHAZkkqMUHoQxJpeqFQLMVJ6HJoGrVf0HC2WqNII2jr7NeFZbhs3l26O6IT4v3Z1YGE5ip/0HFf",
	"Yqztdnu1PbhdEb/iloZuLzjVMbDkAvr6fDV5DJLdn69oqWc66Nn36LprzCJkk03hlrw5VrvRaZubfc2w",
	"72X+RX1eGo2dzpyeFp8Sza00JUEguwqVfcPmKL/1AoZWe7rddueOjetls9fh4eXx0fHZoNc96fta7Sou",
	"TJ2EhqUbeX+9DXbN9iyJIoG5/Xwx/Kud1T83G3vLnJxpiK9jA6zLWuPgz3fNhnZ+l8SilIkCZHAijcYC",
	"Io134usc7DRL60Ws3qsUsLKip1ZlxLA/cPeep6Sq5T9uKU1ea+1C3MAwVKINAoautStIheOKrwNIAKEg",
	"omSCmHQ2cBQ6Yvky/8oVzFrl5wDHMQoxTFE0M42OBVXakrl4130+8KzzEoWYb46gLNdaWrIa85p+kK/K",
	"b5nU/8AogsEH8YoQrCTFkYAdZoDANGMwsvq+qr0dKi1bU7wKn8H5xUI/5VOaRSEIUYRSBHhKWT5v9S2G",
	"QsxQkIo9qNt2Aieo+h6hQrtM2UzpTTJWRNo39Lg+RYBmaa4J3EeUWr2cazKDVhH7dtKSn2PSLK2wzM5i",
	"wrsqsZH7U6trVPnz3WeHfPVKFxCuCb2opdzj22AKyUQqxtee2A55/au0/a0SMUggZi198zQmG4M+IwQC",
	"GEWmr4FAH1hpcIyMZu2oxqCwwmk8PzUFffR6X/06yH8WeDpCpnN7+Wd91a/Qp8U3aGpP9YKmU7PSyo71",
	"jVN8oaY6j8owqTKPM3Rjvp7CawTU26UGzz6CsmN37qNcfyu63dI07Qtq+pdq9Kox+Tep0atu6t81+kUa",
	"vWJT+jhR6JQg+ELa/eXxy8vj/s/Dwfkvx2c+/Z4yw5Bd9jhHzS8iBr8hRb92n1+T1m+Eqy1/5+oPyvZf",
	"r0AozwHXSoJty7d0RWXilTUQItQCXVWLL8ddXbBLibvmWyK+kSMxFCAszdWOHT8XwPoyYGvzGVcGzu5F",
	"T+sTebzgpZIIsQCeUSY8EYTi975SXKT7BxOQJQliAeSoCSJ6Y/6pAiS0xVvuEUbOOGJ25SK/kp5pgriZ",
	"WP1cipaCAaNC1YgiuX3tCVAGyN32c1krL8JBCvDY2C6dChVevUEd4EMb5aqcst5M5+GiK4h7N252KVHf",
	"+W68+268+9ZEvQprKCoZ3knUl2IYrGyuxm77+Z3k/vFpt3cy7J5cHnePfh8e/9brDxyzXtdysKhqOR5O",
	"NVf2a5FjC//nhfA3THB5wR+YL9Yo9H0Fgr4yQa+99oVg9st55egXU0+QR77/hFIAle2NjnVUgDrcMY5S",
	"JFuyKQ+aKbHSAudFfIH2N2IG6A3RnzeBDM9RD2EUtSpS6yeUHqtlyaqfMEZCoNYmLBavbF3ACboQf8qE",
	"xUUvI7bS+31VfG65l89ZKIY3b5eDeATswGimQzZktNCGDLCAEYhhGkxlQph492OG2KzgUKYmZY7IlYCe",
	"RZPlGYe+4fOHy1GKE6b++d2dbtkrzOSmpFbJ0jERMpQyjK5RWELfr9emJ5aJDOIbWtU/vPvcnKuCa0KX",
	"b7eMrssLWhT3k66gO6WEV2jugvKC6FbTE5c7QE9PmrVpbyugkJebK7pwehYq/eN+l+rV0Gu3vbP4o5eU",
	"jXAYqmvlQyOkxqy83l0ZIwv5sfU3Dj8r1IyQLz7+SDkkIDEYeq6qghqREkCizbRqhLCKoWoIhaO9sOpY",
	"2K1PfZIjelSoRzmlXbWy+V+c0VTlmC6tmq1LlclvlZsLz+QxcE4jSi3ONev1lDzkyY7ugiOaCRWmiJiV",
	"+Fevc/hQq/1YPMhUqC9k17eCtA+NF+KAkQ2jGhG5kroogd470mrau2YjyTy4pZLkJO8Sin5OIYKJRTNp",
	"bqK2mIVEabjSOKXujB55m7n4tn6B60kcXZtnZC3Irq/Ta7Ri/+uoQqPmshJ6y2pFe19K8euiYnyACYBO",
	"VuNYUYWiXxVEiLBssWtSubgQNuJ3ynQr/jyCvPWWmLd0S3w32uT1pTIIN82H+i1mdGC3+3HrLTnKyxMX",
	"UeqmopMMbLC/kG5e9B4FAlXlzde2xbbeklzXRkVjjKZKMG1KdiB5QYJYjDnHVIaQVtiB7ul64fRFfhA1",
	"3PTt/yIcIZ+9/g63TBvxgkncPSrt5+PDX3pnw8vj11fH/YFtwtJVlezq6SpyQSMW5uAj06VJPGasoh5K",
	"Tm62Latd2LJeQOWVEAextDlrBMNNVnC+damBYi16WLBp4hbMjgVRCuTVIesSIqpm0OMz35VP/KJ7Oegd",
	"9i66Z4OhXV+o4qk0XIY6uS5ODaDVj3u3OO55FWWWL/2yTiumYlg125XMy8BEI8R9LMfGZiwp7/ho2HPc",
	"xTJyqNxs3RhYS03Xq6XYVz+Xr86kbN3DbBZoQFDiftvb97L+P7jlwKsHWBqKOZJaFWWRSVobnC3rHoyi",
	"kjzPVQ4ptm3ksm6IrbdEJ+xxwCmT6v1oVuTkpThGlkHNEvJLC/cTzFMt+R7bpF2yj1KWKsZtcpO9NmDV",
	"M6NA7KKYXbmVukm4Lf9eaWXtltIrve0xYa9gXX/38PrKPe3OOVZ+ddJyvZKkkJSPZS3307uXz9zTNlDH",
	"prb+DhaYPi9RTK8RgAVLYSigLGwKjkVv8qpwFntKqQyaLQQenEBMTHwtlOVdLPNcRkJK7sukDmUFTI3w",
	"S1lXixL6jpqeV9L8pyJ7vu9HxXd1PhYaPQCWN2uPuFJbA2xcXfWOci9lAmWVHy1BAmyMWsW10hYohSjY",
	"319HK7UqeZabqq2kSTiZ7lVFgiPIgql0exdO8AAm0KRk1BgF/KQI+rIUlY7Iu8FRJMPbQ52OfDGFHIFn",
	"dWrFhdtu6h/pLe8reI9mUmlpqogSeTuxyn153Odut9Y6ZUcO7qg7K5VmmedvT3yViNfgdfeVF3pILaiu",
	"lPTqmpBDlv9iu61UXmrZjMXZHYCtw8HhNduWooXqTLetwhwgY3KpuEEFUBx1XtphJd7nU0Okz/kR7KDl",
	"eb5QUIJTGX0Va6gKUFASSR/LN+E8+XI3krsaro6uLk56h93B8VAGP7rRjjatlIMecWHBsiI5VzRelRpK",
	"fhsWLDc+sn7z34ApqxuGJW9WSpfg1PMU0q1RFn14MB9czszjLEpxEqE5+qy00HFVA8hY/zeyRGyx0263",
	"nS+fFI44nf/slwB5zSD74/uKhRdZ9KHCsh8qVM0/2RcSEHWLWcqDxr/BqLZ/ipxwwuKP3I64XM2m6k0p",
	"sqNMFv8dQS7r+OneEn/mdQYdBvPn9rtWXj4zz5BfnuvWjLrnG7W0dGvNkgktL70U2/tWRFjlxNyzqkL5",
	"WxBmgpnoXtXlTtV3kWO6v/ZDSbK61arycVA2UB7jCOkSIuJPmVInc+uhKQnJ6I3SzGAKIgR5Cn4Q1+4f",
	"pAHnB3m4P4CARlksRc+h/BegTHyLORhH6BaPIpRffuYKv/vKOW+L+6phx4XTr7KsAstQU3XjlrstNwQX",
	"izattAXNIhjKHij6HgG51QXfZ6Jw24n7/UO6c2q5U6oyTtTJaaWmQJZujSmLN00Z9WL4ctlVXxVYgwqm",
	"dvrpiye5PTw0p3tgG5Bsq+IIEyg3u6g6qrc67eOG0HgxZJ46oD6QRdxUHHRuKdO6gcDyhHIusPzJd91g",
	"vm7Q2XnEBVzAWURhCAaUghPIJghs5kwPIJk9xiWyP4bs6NUxYsWhlpQfQvjPt8jb2eAqx9tu1Yx5igP3",
	"FjM3mLsv53voIFc5yzwizPuGmA18j/Cuj/AuwPQAQd4CIacIRqpUtRcLTdI9x4JlAvW26Umm+4bJ0rqy",
	"CK4P+35WE9wT7VzBV7QesDqGyXlm3s5kpkas+8Uq9dznS0O9Hr88LHtw2DUOpNnYrFgi1BI4qz+9Inlz",
	"1bl5ry8gx4E5Mck4LBTSx66YkvpjK8LXqBYRfslGiBGUIg7Ee0QIS3H/QEVZ8rxCw3a7XdS34nrDCaNG",
	"wkIxQustueKqaFyIUqRqOdgfEMnSlf+fIdlnSCqV9Uh2oppZPjCiydX70CxLBLIMdcla56Odp+3Frf/v",
	"hkVqOQ+EQyfOUS/AH3kLXAaBxIt4dQzC6suZtDoGAUpSkDI4HuNA3FUEgvPcbgACSggKUnyN05kuWaY1",
	"4BAliISIBMo9XY9Ol3I/a8UnSYbc07XMmDscTKMffGjGUIj54hd9XVZ86Mz0LpficE2zgxWRVE1SIOnK",
	"BqX+8eWb3uHx8Oqs+6bbO+m+ODm2bUrWVKpCoxdN/A4GB3sLGO21dwqTjBnfppulrTMafzczm+jWZ6jx",
	"7X1BQQSH/Oqo2jFvLJvU6jpMpW0i95jOjdi6p7FAzV/2lS4K27Jdit9aauwjZZ/WRS1XvPH3zEW1xrsv",
	"LvyE0rmI0P4SHuvv6azzLjtJFVLri/ywjuEuCa7W7D/wUri8CQIp2JkqIhuCdMpoNjE+8KJzz70wu9Kj",
	"8kHzZe8aEfJF6OtfkEH7xYohuM402cNrJJRqKvNWbfnwDfh9NIXXpMDMt95VVCIT+75ZaNZeOaiSgG6m",
	"SEIMVrK7/FldCDOtOwm+oW5GTj4uCd1CAABGlEyU0yM3FToNfsbWLOtK2P0JmZSevrklPHQWipponpXx",
	"0LaUZg8gd3cf1fjty8H8ArI5cKG6lrh7r3j2U5vONa6jsiN6Q6STQOfCS9Gs6ra75K6rn0uOr2ICYpiC",
	"jYuznwTS99/89OTe9xG9FGtzry8PVaL0XAemtWzVpbC4qSdkUuORzF/2Jaqpz0x6mvqLX0+sK3x9AHde",
	"kwB/klXjE3yLIq4hRaJZEwhYdNrtJojhLdhut9tOuPleZ7vGh4o/If965Sex6ifWONiWLdnz7sQdrxlt",
	"ccA3juEEbYm9O1RZorKzn4B8EWxI25OC6n8TMnmypIdUTcOvJ/93G0fzpuq/8U7Fr+VU5YEr/CCPPRZD",
	"LF8CYN11njXdUKbwI8frf/W12fAgm+OYoOQa5aLZ0IxtXcxziQVLf42PAVkNFAuvTtHO7mBrK6IBjKaU",
	"pwf77f22NqN5klUuGA2zoOi1yCp98UoWMzHKuxxG5eF+tjwZqtC0ahGqBby5Y/GCyWhzVnVlbgfNvNNm",
	"3tiyGEKWB60OcGVX9y66jBbfyarVng+V8zPCYxTMggh5v81rM84zV1Vcw76RSjkmddxdh+yYkUq9xPVY",
	"GkXnJMblElDVI08ZFBrBxMqF0zrC53ef/38AAAD//9PoCZ7R8wAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
